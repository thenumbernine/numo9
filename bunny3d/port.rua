#!/usr/bin/env rua
--[[
TODO I replaced saving-as-binary with saving-as-.obj so ...
--]]
local infn, outfn = ...
assert(infn and outfn, "expected infn outfn\nex: bunny.txt mesh.3d")

local vec3d = require 'vec-ffi.vec3d'
local meshstrs = assert(path(infn):read())
:trim()
:split'\n':mapi(|l| do
	local color, line = l:match('^(%x%x) (%x+)$')
	assert(color, "expected color, line")
	assert.eq(#line % (2*2*3*3), 0, "line should be a set of hex encoding of 9 shorts")
	return {
		color = tonumber(color, 16),
		line = line:trim(),
	}
end)

-- map from 12-hex-char vtx str to 0-based colorkey
local colorKeyForVtxStr = {}
-- holds sets of 12 hex chars = 1 vertex xyz in int16_t
local vtxstrs = table()
for _,meshstr in ipairs(meshstrs) do
	for vtxstr in meshstr.line:gmatch(('.'):rep(12)) do
		vtxstrs:insert(vtxstr)
		colorKeyForVtxStr[vtxstr] = meshstr.color
	end
end

-- gather unique vtx strings
local uniquevtxstrs = vtxstrs:mapi(|s| (true, s)):keys()

-- convert to vertexes {x,y,z}
local vtxs = uniquevtxstrs:mapi(|s| do
	local v = table()
	for i=1,#s,4 do
		v:insert(tonumber(
			int16_t(tonumber(s:sub(i, i+3), 16))
		))
	end
	assert.len(v, 3)
	return {
		v = vec3d(table.unpack(v)),
		c = colorKeyForVtxStr![s],
	}
end)
-- get mapping from vertex string to index in vtxs
local vtxIndexForStr = uniquevtxstrs:mapi(|s,ip1| (ip1-1, s)):setmetatable(nil)

local indexes = table()
for _,vtxstr in ipairs(vtxstrs) do
	indexes:insert((assert.index(vtxIndexForStr, vtxstr)))
end



-- find volume center and offset to there
local calcCOM=||do
	local com = vec3d()
	local vol = 0
	for i=1,#indexes,3 do
		local v1 = vtxs[1+indexes[i]].v
		local v2 = vtxs[1+indexes[i+1]].v
		local v3 = vtxs[1+indexes[i+2]].v
		local tetvol = v1:dot(v2:cross(v3)) / 6	-- det|v1, v2, v3| / 6
		vol += tetvol
		com += (v1 + v2 + v3) * (tetvol / 4)	-- /4 because we include (0,0,0) as a tetrahedron vertex
	end
	com /= vol
	return com, vol
end
local offsetCOM=||do
	-- get COM
	local com, vol = calcCOM()
	print('com mag', com:length())
	-- offset to zero
	for i=1,#vtxs do
		vtxs[i].v -= com
	end
end
for i=1,10 do
	offsetCOM()	-- turns out it converges more slowly than I'd like
end
-- find backfacing tris (why are they here?)
-- assumes the COM is zero
local flipBackFacing=||do
	-- TODO
	-- it's not a sphere
	-- so the best way is consensus, by ensuring that our orientation matches our neighbors
	local com = calcCOM()
	local numBack = 0
	for i=1,#indexes,3 do
		local v1 = vtxs[1+indexes[i]].v
		local v2 = vtxs[1+indexes[i+1]].v
		local v3 = vtxs[1+indexes[i+2]].v
		local c = (v1+v2+v3):unit()
		local n = (v2-v1):cross(v3-v2):unit()
		if (c - com):dot(n) < 0 then
			numBack+=1
--print'!!! backfacing tri !!!'
			indexes[i], indexes[i+1] = indexes[i+1], indexes[i]
		end
	end
	return numBack
end
print('num backfacing', flipBackFacing())
for i=1,10 do
	offsetCOM()	-- in case it changed thanks to fixing backfacing tris
end
print('num backfacing', flipBackFacing())

local o = require 'stl.vector-lua' 'int16_t'
o:emplace_back()[0] = #vtxs
o:emplace_back()[0] = #indexes
for j,vtx in ipairs(vtxs) do
	-- TODO how about a solid-face format as well? for tri3d() ?
	for i=0,2 do
		o:emplace_back()[0] = math.clamp(vtx.v.s[i], -32768, 32767)
	end

	local colorOffset = vtx.c << 3
	local uv = ffi.cast('uint8_t*', o:emplace_back())
	uv[0] = colorOffset
	uv[1] = 0
	-- uv
	if j % 3 == 0 then
		uv[1] += 7
	elseif j % 3 == 2 then
		uv[0] += 7
	end
end
for _,index in ipairs(indexes) do
	o:emplace_back()[0] = index
end
assert.eq(2 + #vtxs * 4 + #indexes, #o)
assert(path(outfn):write(o:dataToStr()))
