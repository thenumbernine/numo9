#!/usr/bin/env rua
--[[
finding all unique orientations of 6-bit representations of cube's 48 isometric transforms.
for using Euler angles A = Rz * Ry * Rx * Sx
turns out storing z:y:x:s as 2:1:2:1 only covers 40 of 48
storing z:y:x:s as 2:2:1:1 covers all 48
--]]
local matrix = require 'matrix'
local I = matrix{3,3}:eye()
local sx = matrix{
	{-1,0,0},
	{0,1,0},
	{0,0,1},
}
local sy = matrix{
	{1,0,0},
	{0,-1,0},
	{0,0,1},
}
local sz = matrix{
	{1,0,0},
	{0,1,0},
	{0,0,-1},
}
local rx = matrix{
	{1,0,0},
	{0,0,-1},
	{0,1,0},
}
local ry = matrix{
	{0,0,1},
	{0,1,0},
	{-1,0,0},
}
local rz = matrix{
	{0,-1,0},
	{1,0,0},
	{0,0,1},
}
local baseRots = table{rx, ry, rz, sx, sy, sz}

local specialOrientations = table()	-- orientation that has a previous duplicate
local duplicateIndexes = table()
local uniqueRots = table()
local rots = table()	-- all orientation rotations, should be 32
local ms = I
for is=0,1 do
	local mx = I
	for ix=0,1 do
		local my = I
		for iy=0,3 do
			local mz = I
			for iz=0,3 do
				local m = mz * my * mx * ms
				rots:insert(m)
				local orientation = iz | (iy << 2) | (ix << 4) | (is << 5)
				local dupindex = uniqueRots:find(m)
				if dupindex then
					duplicateIndexes:insert{from=orientation, to=dupindex}
					specialOrientations[orientation] = true
				else
					uniqueRots:insert(m)
				end
print('orient='..orientation..'\tiz='..iz..'\tiy='..iy..'\tix='..ix
	..'\tis='..is
	..'\tdup='..(dupindex and dupindex-1 or ''))
				mz *= rz
			end
			my *= ry
		end
		mx *= rx
	end
	ms *= sx
end

print('#unique', #uniqueRots)
print('duplicate indexes:')
print(tolua(duplicateIndexes))
print()

-- now for each orientation, left-apply a rotate-x, rotate-y, rotate-z and see where we get
-- such that applying a column 4x should bring you back to the start (but never before 4x)
print()
print[[
-- orientation rotations for the upper 6 rotation bits of the voxel
-- the first 3 axis are for rotations, and have 3 entries for each 90 degree rotation
-- the second 3 are for scales, and have 1 entry for the scale in the x, y, and z direction.
-- This represents a left-multiply of the rotation to the orientation.
-- orientationRotations[orientation+1][axis+1][angle in 90 degree increments +1] = 0-based orientation
]]
print'local orientationRotations = {'
for i,m in ipairs(rots) do
	local allinds = table()
	for j,r in ipairs(baseRots) do
		local m2 = m
		local rotinds = table()
		allinds:insert(rotinds)
		local n = (rawequal(r, sx) or rawequal(r, sy) or rawequal(r, sz))
			and 2 or 4
		for k=1,n do
			m2 = r * m2
			if k == n then
				assert.eq(m, m2)
			else
				local index = assert(rots:find(m2)) - 1
				rotinds:insert(index)
			end
		end
	end
	print('\t'..tolua(allinds, {indent=false})..',')
end
print'}'

local orientationInv = table()
for i,m in ipairs(rots) do
	local invIndex = assert(rots:find((m:inv()))) - 1
	orientationInv:insert(invIndex)
end
print()

print[[
-- inverse orientation for orientation
-- [orientation+1] = rotated orientation
]]
print('local orientationInv = '..tolua(orientationInv))
print()

--[[
sides are encoded 0 bit = sign, 12 bit = axis so
0 = x+
1 = x-
2 = y+
3 = y-
4 = z+
5 = z-

calculate side transformation based on orientation or its inverse
--]]

local sideToVec = |sideIndex| do
	local sign = 1 - 2 * bit.band(1, sideIndex)
	local axis = bit.rshift(sideIndex, 1)
	local v = matrix{0,0,0}
	v[axis+1] = sign
	return v
end
local sideVecs = range(0,5):mapi(sideToVec)
for sideIndexPlusOne,v in ipairs(sideVecs) do
	print('sideVecs['..sideIndexPlusOne..'] = '..v)
end

local vecToSideIndex = |v| do
	-- better not have numerical precision errors
	return assert(sideVecs:find(v)) - 1
end

-- for each side
-- for each orientation
-- give the resulting side
local rotateSideByOrientation = table()
local allinvrotsides = table()
for sideIndex=0,5 do
	local v = sideVecs[sideIndex+1]
	local rotsides = table()
	for orientationPlusOne,m in ipairs(rots) do
		if not specialOrientations[orientationPlusOne-1] then
			rotsides[orientationPlusOne] = vecToSideIndex(m * v)
		end
	end
	rotateSideByOrientation:insert(rotsides)
end
print'-- [sideIndex+1][orientation+1] = rotated sideIndex'
print('local rotateSideByOrientation = '..tolua(rotateSideByOrientation))


-- just store the whole group orientation table
local orientationMul = {}
for i=0,#rots-1 do
	if not specialOrientations[i] then
		orientationMul[i+1] = {}
		for j=0,#rots-1 do
			if not specialOrientations[j] then
				local mulIndex = rots:find((rots[i+1] * rots[j+1]))
				orientationMul[i+1][j+1] = mulIndex and (mulIndex-1)
			end
		end
	end
end
print'--[orientation+1][orientation+1] = orientation'
print('orientationMul = '..tolua(orientationMul))
