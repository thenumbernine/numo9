#!/usr/bin/env rua
--[[
finding all unique orientations of 5-bit representations of cube's 24 (right-handed) isometric transforms.
for using Euler angles A = Rz * Ry * Rx
turns out storing z:y:x as 2:1:2 only covers 20 of 24
storing z:y:x as 2:2:1 covers all 24
--]]
local matrix = require 'matrix'
local I = matrix{3,3}:eye()
local rx = matrix{
	{1,0,0},
	{0,0,-1},
	{0,1,0},
}
local ry = matrix{
	{0,0,1},
	{0,1,0},
	{-1,0,0},
}
local rz = matrix{
	{0,-1,0},
	{1,0,0},
	{0,0,1},
}
local baseRots = table{rx, ry, rz}

local duplicateIndexes = table()
local uniqueRots = table()
local rots = table()	-- all orientation rotations, should be 32
local sx = I
for ix=0,1 do
	local sy = I
	for iy=0,3 do
		local sz = I
		for iz=0,3 do
			local m = sz * sy * sx
			rots:insert(m)
			local orientation = iz | (iy << 2) | (ix << 4)
			local dupindex = uniqueRots:find(m)
			if dupindex then
				duplicateIndexes:insert{from=orientation, to=dupindex}
			else
				uniqueRots:insert(m)
			end
print('orient='..orientation..'\tiz='..iz..'\tiy='..iy..'\tix='..ix..'\tdup='..(dupindex and dupindex-1 or ''))
			sz *= rz
		end
		sy *= ry
	end
	sx *= rx
end

print('#unique', #uniqueRots)
print('duplicate indexes:')
print(tolua(duplicateIndexes))
print()

-- now for each orientation, left-apply a rotate-x, rotate-y, rotate-z and see where we get
-- such that applying a column 4x should bring you back to the start (but never before 4x)
print()
print[[
-- orientation rotations for the upper 5 rotation bits of the voxel
-- indexed[orientation+1][axis+1][angle in 90 degree increments +1] = 0-based orientation
]]
print'local orientationRotations = {'
for i,m in ipairs(rots) do
	local allinds = table()
	for j,r in ipairs(baseRots) do
		local m2 = m
		local rotinds = table()
		allinds:insert(rotinds)
		for k=1,4 do
			m2 = r * m2
			if k == 4 then
				assert.eq(m, m2)
			else
				local index = assert(rots:find(m2)) - 1
				rotinds:insert(index)
			end
		end
	end
	print('\t'..tolua(allinds, {indent=false})..',')
end
print'}'

local invOrientations = table()
for i,m in ipairs(rots) do
	local invIndex = assert(rots:find((m:inv()))) - 1
	invOrientations:insert(invIndex)
end
print()

print[[
-- inverse orientation for orientation
-- [orientation+1] = rotated orientation
]]
print('local orientationInv = '..tolua(invOrientations))
print()

--[[
sides are encoded 0 bit = sign, 12 bit = axis so
0 = x+
1 = x-
2 = y+
3 = y-
4 = z+
5 = z-

calculate side transformation based on orientation or its inverse
(TODO how about just provide a lookup of inverse table)
--]]

local sideToVec = |sideIndex| do
	local sign = 1 - 2 * bit.band(1, sideIndex)
	local axis = bit.rshift(sideIndex, 1)
	local v = matrix{0,0,0}
	v[axis+1] = sign
	return v
end
local sideVecs = range(0,5):mapi(sideToVec)

local vecToSide = |v| do
	-- better not have numerical precision errors
	return assert(sideVecs:find(v)) - 1
end

-- for each side
-- for each orientation
-- give the resulting side
local allrotsides = table()
local allinvrotsides = table()
for sideIndex=0,5 do
	local v = sideToVec(sideIndex)
	local rotsides = table()
	for _,m in ipairs(rots) do
		rotsides:insert(vecToSide(m * v))
	end
	allrotsides:insert(rotsides)
end
print'-- [sideIndex+1][orientation+1] = rotated sideIndex'
print('local rotateSideByOrientation = '..tolua(allrotsides))
