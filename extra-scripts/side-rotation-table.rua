#!/usr/bin/env rua
local matrix = require 'matrix'
--[[
requires 3d-rot-isometry.rua to be run to produce rot3ds.rua

sides are encoded 0 bit = sign, 12 bit = axis so
0 = x+
1 = x-
2 = y+
3 = y-
4 = z+
5 = z-

calculate side transformation based on orientation or its inverse
(TODO how about just provide a lookup of inverse table)
--]]

local sideToVec = |sideIndex| do
	local sign = 1 - 2 * bit.band(1, sideIndex)
	local axis = bit.rshift(sideIndex, 1)
	local v = matrix{0,0,0}
	v[axis+1] = sign
	return v
end
local sideVecs = range(0,5):mapi(sideToVec)

local vecToSide = |v| do
	-- better not have numerical precision errors
	return assert(sideVecs:find(v)) - 1
end

-- generated from running 3d-rot-isometry.rua
local rot3ds = table.mapi(require 'rot3ds', |m| matrix(m))

-- for each side
-- for each orientation
-- give the resulting side
local allrotsides = table()
local allinvrotsides = table()
for sideIndex=0,5 do
	local v = sideToVec(sideIndex)
	local rotsides = table()
	for _,m in ipairs(rot3ds) do
		rotsides:insert(vecToSide(m * v))
	end
	allrotsides:insert(rotsides)
end
print'-- [sideIndex+1][orientation+1] = rotated sideIndex'
print('local rotateSideByOrientation = '..tolua(allrotsides))
